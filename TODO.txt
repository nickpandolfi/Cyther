
MAINTAIN

    Keep __all__ up to date with all the useful functions

    Comment and properly docstring everything

    Keep the -h follow all the other common -h practices

    Make sure that the -h is up to date, including all the version info of all the external features (gcc/Cython)

    Make sure that you constantly search for the assumptions cyther makes

    Make my getIncludeAndRuntime() function is up to date with build_ext in distutils

    Any name cool badges to add? Make sure you got all the recent and useful ones
    Use http://shields.io/ to generate non changing badges

    Make sure the test_cyther.py file is updated to include the latest features (test everything!)


EASY FIX

    Whats up with CYTHER_CONFIG_FILE? Should we use it?

    Make sure a new window doesnt get spawned on the subprocess calls (on some systems it does, some it doesnt)

    How to deal with non-standard extensions that people might be using? Don't error, but just have it print that
    it is non standard, and work anyway? What about Regex?

    Update tags
        take out codacy

    Fix the help text in the readme to not have 'Nothing here yet'


MEDIUM FIX

    Fix issue posted on cyther/issues
        Investigate cold installations and usage of other operating systems

HARD FIX

    Get the operating system dependant flags that are passed to gcc by distutils and inject them when building the
    preset (see question you posed)

    Make sure that the file order provided doesn't matter when compiling multiple files that may depend on one another


EASY NEW FEATURES

    Make a --test option in cyther command interface. (Makes testing much easier and quicker)

    Have 'help' text print out all the directories it is using

    Get the arguments of run(timer=True) to work properly, or be automatic, like IPython

    Get crawl to find libpython, and also rename crawl to 'what'


HARD NEW FEATURES

    Erase Cyther's usage of distutils entirely

    Instead of the include option, have the system automatically detect the python {}.get_include() modules

    Have a scriptble system of talking to the core and passing in arguments. THIS WOULD BE GREAT!!

    Add cl to the options that are available for compilers

    Say the search for the directories necessary for the runtime compilation fails, and returns nothing. Then run the
    crawl algorithm over the whole DRIVE to find a lib file that matches the REGEX definition


LOW PRIORITY

    An option to just build the C, or to just take the C and build only the extension
    How could cyther be used with distutils??

    Function to clean a directory of everything 'locally build' related, or move it to a cythercache
    A function to remove EVERYTHING cyther related

    Always back up the previous compile if there was one. Then if there is an error, don't overwrite it with anything,
    but instead, keep the backup version. Have the new compilation attempt be built in the __cythercache__ directory

########################################################################################################################

BEFORE DEPLOY (for me)

    Make sure that the version specified makes sense (major.minor.patch)

    Make sure that the README reflects the new interface changes

    Make sure that the CHANGELOG is up to date and includes the current version change

    Delete the comments that are no longer needed. Any junk or temporary commented code should be extracted

    Write a test script that actually tests the whole deal. Have it run every scenario and then
    USE the actual extension that it makes


QUESTIONS (for me to ask myself)

    Split cyther.py into several other modules?

    Where is the best spot to put the README and all the other files?

    Add more presets?? I need to do a brainstorming situation...

    Don't have args and file, have only one object with everything in it. Does this even make sense?

    Is it wise to take out the checking procedures with the getIncludeAndRuntime() function. Why are they necessary??

    Would it be possible to automatically send me their __cytherinfo__ variable?

    Will sift ever have to return multiple results for the lib directories??

    What about lines like this platform.platform().strip().lower().startswith('windows')??
    What do the platform names even look like? Is their structure reliable? Does it need to be?

    What about bcpp or cygwin??

    Should we even give the option to build locally in the same file?

    Do the commands to argparse need to be changed. Maybe give them better names, and give each a long name.

    Is it necessary to make sure that os.pardir will never be a problem??

    How about using tempfile for the building files??

    What about packaging the libraries with cyther?? Are they cross platform? How to even get these libs?

    What is the difference between os.name and sys.platform and platform.platform?
    Why do some return operating systems, and some return processor architectures
